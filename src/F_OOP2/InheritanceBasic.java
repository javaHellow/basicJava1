package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
		
		/*
		1. 상속 (is a : ~은 ~ 이다)
			- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
			- 적은 양의 코드로 새로운 클래스를 작성할수 있다.
			- 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 
			 	키워드 'extends'와 함께 써주기만 하면 된다.
			 	
			 	classs child extends parent{
			 		.......
			 	}
			 	
			 	- 상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다.
			 		: 조상클래스 - 부모클래스, 상위클래스, 기반클래스,
			 		: 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
			 		
			 	- 멤버만 상속 받는다.	
			 	- 자손클래스의 멤버의 개수는 조상 클래스보다 같거나 많다.(보통은 많음)
			 		
		2. 포함 (has a : ~은 ~을 포함하고 있다)
			- 상속이외에 클래스를 재사용하는 방법
			- 한 클래스의 멤버변수로 다른클래스를 선언하는 방법이다.
		
		3. 단일상속
			- 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
			  class TVCR extends TV, VCR{//불가능
			  
			  }
			- Tv와 VCR에 동일한 멤버가 있을때 어떤것을 상속받을지 알 수 없다.
			- VCR의 멤버명을 바꾼다면 그동안 VCR의 멤버를 사용하던 부분들은 모두 수정해 주어야 한다.
			- 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있다.
			
		4. Object클래스 (모든 클래스의 조상)
			- 모든 클래스의 상속 계층도 의 가장위에 위치하는 조상 클래스이다.
			- 다른클래스로부터 상속받지 않는 클래스들은 자동적으로 Object클래스를 상속받는다.
			
			class Tv{
			
			}
			=> 컴파일후
			class Tv extends Object{
			 
			  오브젝트가 숨어있음
			  
			}  
			  
			- toString()나 equals()와 같은 메서드를 따로 정의하지 않고 사용할수 있는것은
			  Object클래스에 정의된 것들이기 때문이다.
			  
		5. 오버라이딩(override)
			- 조상클래스로부터 상속받은 메서드의 내용을 변경(재정의)하는 것.
			- 오버라이드 되기 위한 조건 => 선언부가 일치 해야 한다.(대체로) 구현부는 달라도 상관없음
				: 자손클래스 에서 오버라이드 하는 메서드는 조상클래스의 메서드의 명과 동일해야 한다.
				: 매개변수의 타입과 개수가 같아야 한다. !(타입 || 개수) => 타입o  && 개수o
				: 리턴타입이 같아야 한다.
				: 접근제어자를 조상 클래스보다 좁은 범위로 설정할 수 없다.  (public은 접근제어가 없는 반면에 프라이벗은 접근제어가 걸려있다) //퍼블릭은 가장 큰 존재
				: 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다. 
		
		6 super.
			- 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 있을때 서로 구분하기 위해 사용
			- 조상멤버와 자신의 멤버를 구별하는데 사용한다는 것을 제외하고는 this. 과 근본적으로 동일
			- static메서드에서 사용할 수 없다.(인스턴스가 있어야만 찾아서 사용가능)
			
		7 super() - 조상클래스의 생성자를 호출
			- this()와 마찬가지로 super()역시 생성자 이다.
			- this()는 같은 클래스의 다른 생성자를 호출
			  super()는 부모클래스의 생성자를 호출
			- 생성자의 첫 줄에는 조상 클래스의 생성자를 호출해야 한다.
			  자손클래스의 멤버가 조상클래스의 멤버를  사용할수 있으므로 조상의 멤버들이 먼저
			  초기화 되어야 한다.
			
		8. 제어자
			- 클래스, 변수 메서드의 선언부에 사용된다.
			- 접근제어자와 그 외 제어자로 나누어진다.
			- 접근제어자 : private , default, protected, public
			- 그외 제어자 : static, final, abstract, native.....
			- 접근제어자를 제일 왼쪽에 보편적으로 많이 둔다.
			- static(클래스의, 공통적인)
				: 멤버변수, 메서드, 초기화 블럭에 사용된다.
				: static변수
				  	-> 모든인스턴스에서 공통적으로 사용한다.
				  	-> 인스턴스를 생성하지 않고도 호출할수 있다.
				 	-> 클래스가 메모리에 로드될때 생성된다.
				: static메서드
					-> 인스턴스 생성없이 사용 가능
					-> 클래스 메서드 내에서 인스턴스 멤버를 호출할 수 없다.
			
			- final(마지막의 , 변경할수 없는 (상수))
				: 변수에 사용시 변경할수 없는 상수가 된다.
				: 메서드에 사용시 오버라이딩 할수 없다.
				: 클래스에 사용시 상속할수 없는 클래스가 된다.
				
			- abstract( 추상의, 미완성된)
				: 메서드와 클래스에만 사용가능
				: 메서드에 사용시 구현부는 작성하지 않는다.
					void method();
			
		9. 접근제어자
		 	- private : 같은 클래스내에서 접근가능
		 	- default : 같은 패키지 내에서 접근가능
		 	- protected : 같은 패기지 + 다른 패키지의 자손클래스에서 접근 가능
		 	- public : 접근제한이 없다.
		 	- 클래스에는 default, public만 사용 가능 
		 	
		10. 캡슐화
			- 접근제어자를 사용하는 이유
				: 외부로 부터 데이터를 보호하기 위한 목적
				: 외부에는 불필요한, 내부턱으로만 사용되는 부분을 감추기 위해 사용
		
		11. 다형성(polymorphism)	
			- 여러가지 형태를 가질수 있는 능력
			- 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
				Car c = new FireCar();
				Car c = new Ambulance();
			- 부모타입의 참조변수로 자손타입의 인스턴스를 참조할수 있다.	
				
		12. 참조변수의  형변환 (상속)
			- 서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
			- 자손타입 -> 부모타입(up-casting) : 형변환 생략 가능
			- 부모타입 -> 자손타입(down-casting) : 형변환 생략 불가
		
		13. instanceof
			- 참조변수가 창조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
			- 연산결과가 true 이면 참조변수가 검사한 타입으로 형변환이 가능하다.
			- 클래스메서드와 클래스 변수는 참조변수의 타입에 영향을 받는다.
			- 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
			
		14. 매개변수의 다향성
			- 참조변수의 다형적인 특징을 메서드의 매개변수에도 적용된다.
		
		15. 여러객체 배열 , Vector
			- 조상타입의 참조변수로 자손타입의 인스턴스를 참조할수 있다.(다양성)	
			- Vector
				: 배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
				    이름 Vector클래스를 이용하여 해결할 수 있다.
				: 동적으로 크기가 관리되는 객체배열 이라고 할 수 있다. 
				
			  Vector v = new Vector();
			  Vector() : 10개의 객체를 저장할수 있는 Vector 인스턴스를 생성한다.
			  add()	   : Vector에 객체를 추가한다.
			  remove() : Vector에 객체를 삭제한다.
			  isEmpty(): Vector에 객체를 가지고 있는지 확인.
			  Object get(int inde
			  x) : index번쨰 객체를 반환한다.
			  int size() : Vector에 객체가 저장된 개수를 반환한다.
	
	
		16. 추상클래스(abstract class)
			- 미완성된 클래스 : 미완성된 메서드를 가지고 있다는 의미
			- 구성
				abstract class 클래스명{
				
				}
			- 추상 메서드
				: 메서드는 선언부와 구현부와 구성되어 있다.
				: 추상 메서드는 선언부만 작성되어 있고 구현부는 작성되지 않은 메서드를 의미한다.
				abstract 리턴타입 메서드면();  구현부가 있으면 안된다.
			- 	추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 클래스의 추상메서드를
				구현해 주면 된다.
				
		17. 인터페이스(interface)
			- 일종의 추상클래스 이지만 추상메서드와 상수만을 멤버로 가진다.
			- 인터페이스의 작성
			  interface 인터페이스명{
			  	 public static final 변수타입 변수명 = 값;
			  	 public abstract 반환타입 메서드명(매개변수타입 명,....); //구현은 하지 않는다.		  	 
			  }
	
			 	: 모든 멤버변수는 public static final 이어야 한다. => 생략할 수 있다.
			 	: 모든 메서드는 public abstract이어야 한다.=> 생략할수 있다.
			 	 
			 - 인터페이스의 상속
			 	: 인터페이스는 인터페이스만 상속받을수 있다.
			 		=> 구현된 메서드를 상속받으면 더이상 인터페이스가 아니게 된다.
			 	: 인터페이스는 다중상속 가능하다.
			 	: Object 와 같은 최고 조상은 없다.
			 	
			 - 인터페이스의 구현
			 	: 자체로는 인스턴스를 생성할 수 없다.
			 	: 자신의 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.+
			 	: 클래스의 확장(extends), 인터페이스의 구현(implements)
			 	: ~able
			 		=> Movable (예전)
					=> IMove => IMoveImpl (요즘)
	
			 - 인터페이스의 다형성
			 	: 인터페이스타입의 참조변수로 그를 구현한 구현체의 인스턴스를 창조할 수 있다.
			 	
			 - 인터페이스의 장점
			 	: 개발시간을 단축 할 수 있다.
			 	: 표준화가 가능하다.
			 	: 서로 관계가 없는 클래스들에게 관계를 맺어줄수 있다.
			 	: 독립적인 프로그래밍이 가능하다.
			 	: 7-26예제 꼭 해보세요~
			 	
			 - 인터페이스의 이해
			 	: 클래스를 사용한 쪽(user)과 클래스를 제공하는 쪽(provider)이 있다.
			 	 A(제공하는쪽) - I(선언부) - B(사용하는 쪽)
			  
		 18. 내부클래스(inner class)
			 - 내부클래스란?
			 	: 클래스 내에 선언된 클래스
			 	: 서로 쉽게 접근할수 있고 외부에서 볼때 불필요한 클래스를 감ㅊㅇ으로
			 	   복잡성을 줄일 수 있다.
			 - 인스턴스클래스
			 	: 외부클래스(밖에 있는 클래스)의 인스턴스 멤버들과 관련된 작업을 수행한다.
			 - 스태틱클래스
			 	: 외부클래스의 클래스멤버들과 관련된 작업을 수행, 클래스 메서드를 관련된 작업을 수행한다
			 - 지역클래스
			 	: 외부클래스의 메서드나 초기화블럭 안에 선언, 선언 영역 내에서만 사용 가능
			 - 익명클래스
			 	: 클래스의 선언과 객체의 생성을 동시에 진행한다.
			 	: 이름이 없는 클래스(일회용)
			 -
				
		*/
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}
